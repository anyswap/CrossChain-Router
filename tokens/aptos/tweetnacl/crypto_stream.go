package tweetnacl

/*
#include "tweetnacl.h"
*/
import "C"

import (
	"fmt"
)

// The number of bytes in the secret key for crypto_stream.
const STREAM_KEYBYTES int = 32

// The number of bytes in the nonce for crypto_stream.
const STREAM_NONCEBYTES int = 24

// The number of bytes in the secret key for crypto_stream_salsa20.
const STREAM_SALSA20_KEYBYTES int = 32

// The number of bytes in the nonce for crypto_stream_salsa20.
const STREAM_SALSA20_NONCEBYTES int = 8

// Wrapper function for crypto_stream.
//
// Generates a cipher stream of size 'length' as a function of the key and nonce.
//
// Ref. http://nacl.cr.yp.to/stream.html
func CryptoStream(length int, nonce, key []byte) ([]byte, error) {
	if len(nonce) != STREAM_NONCEBYTES {
		return nil, fmt.Errorf("Error generating cipher stream (%v)", "invalid nonce")
	}

	if len(key) != STREAM_KEYBYTES {
		return nil, fmt.Errorf("Error generating cipher stream (%v)", "invalid key")
	}

	stream := make([]byte, length)
	N := (C.ulonglong)(length)

	rc := C.crypto_stream(makePtr(stream),
		N,
		makePtr(nonce),
		makePtr(key))

	if rc == 0 {
		return stream, nil
	}

	return nil, fmt.Errorf("Error generating cipher stream (%v)", rc)
}

// Wrapper function for crypto_stream_xor.
//
// Encrypts a message using a secret key and a nonce. The returned ciphertext is the
// plaintext XOR with the output of the stream generated by crypto_stream with the
// secret key and nonce.
//
// Ref. http://nacl.cr.yp.to/stream.html
func CryptoStreamXor(message, nonce, key []byte) ([]byte, error) {
	if len(nonce) != STREAM_NONCEBYTES {
		return nil, fmt.Errorf("Error generating stream ciphertext (%v)", "invalid nonce")
	}

	if len(key) != STREAM_KEYBYTES {
		return nil, fmt.Errorf("Error generating stream ciphertext (%v)", "invalid key")
	}

	ciphertext := make([]byte, len(message))
	N := (C.ulonglong)(len(ciphertext))

	rc := C.crypto_stream_xor(makePtr(ciphertext),
		makePtr(message),
		N,
		makePtr(nonce),
		makePtr(key))

	if rc == 0 {
		return ciphertext, nil
	}

	return nil, fmt.Errorf("Error generating stream ciphertext (error code %v)", rc)
}

// Wrapper function for crypto_stream_salsa20.
//
// Uses Salsa20 as the underlying cipher to produces a 'length' stream as a function of
// the key and nonce.
//
// Ref. http://nacl.cr.yp.to/stream.html
func CryptoStreamSalsa20(length int, nonce, key []byte) ([]byte, error) {
	if len(nonce) != STREAM_SALSA20_NONCEBYTES {
		return nil, fmt.Errorf("Error generating SALSA-20 cipher stream (%v)", "invalid nonce")
	}

	if len(key) != STREAM_SALSA20_KEYBYTES {
		return nil, fmt.Errorf("Error generating SALSA-20 cipher stream (%v)", "invalid key")
	}

	stream := make([]byte, length)
	N := (C.ulonglong)(length)

	rc := C.crypto_stream_salsa20(makePtr(stream),
		N,
		makePtr(nonce),
		makePtr(key))

	if rc == 0 {
		return stream, nil
	}

	return nil, fmt.Errorf("Error generating SALSA-20 cipher stream (%v)", rc)
}

// Wrapper function for crypto_stream_salsa20_xor.
//
// Encrypts a message using salsa20 as the underlying cipher. The returned ciphertext is
// the plaintext XOR with the output of the stream generated by crypto_stream_salsa20
// with the supplied secret key and nonce.
//
// Ref. http://nacl.cr.yp.to/stream.html
func CryptoStreamSalsa20Xor(message, nonce, key []byte) ([]byte, error) {
	if len(nonce) != STREAM_SALSA20_NONCEBYTES {
		return nil, fmt.Errorf("Error generating SALSA-20 stream ciphertext (%v)", "invalid nonce")
	}

	if len(key) != STREAM_SALSA20_KEYBYTES {
		return nil, fmt.Errorf("Error generating SALSA-20 stream ciphertext (%v)", "invalid key")
	}

	ciphertext := make([]byte, len(message))
	N := (C.ulonglong)(len(ciphertext))

	rc := C.crypto_stream_salsa20_xor(makePtr(ciphertext),
		makePtr(message),
		N,
		makePtr(nonce),
		makePtr(key))

	if rc == 0 {
		return ciphertext, nil
	}

	return nil, fmt.Errorf("Error generating SALSA-20 stream ciphertext (%v)", rc)
}
